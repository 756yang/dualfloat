双数，是两个数联合。为了更高的计算精度，可以用两个数表示计算结果，这就是双数运算。

双数运算的基础是带余四则运算。
误差阶数erp(相当于ulp,最小精度单位)，是指浮点数最後一个有效位取反後与原来浮点数的距离。
通常，double类型有53位尾数，故而erp(double)=2^(ilogb(double)-52).
float有24位尾数，故而erp(float)=2^(ilogb(float)-23).
精度误差eps,是浮点数的舍入精度，eps(double)=2^(-53), eps(float)=2^(-24).
ulp(a)=2*eps(a)*2^ilogb(a).
精度位数，指浮点数有效舍入的二进制位数，double类型有53位精度，float类型有24位精度。

规格化：如果双数的高位hi和低位lo满足abs(lo)<=0.5erp(hi)，则称此双数是规格化的，否则非规格化。
双数，要求erp(hi)>=erp(lo)，此外，双双数亦要求按erp排序，诸如此。

浮点数的重叠与干扰：
如果erp(A)>abs(B)或erp(B)>abs(A)或A==0或B==0，则称A与B互不重叠。
如果0.5*erp(A)>=abs(B)，则称A与B不干扰。
很明显，规格化的双数，高位部分与低位部分不干扰。
互不重叠：序列中顺序或逆序任取相邻两个数A,B，都满足A与B不重叠，则称此序列互不重叠。
互不干扰：序列中顺序或逆序任取相邻两个数A,B，都满足A与B不干扰，则称此序列互不干扰。
完全不干扰：序列中顺序或逆序任取相邻两个数A,B，都满足0.5*ulp(A)>=abs(B)，则称此序列完全不干扰。
完全不干扰的序列可以直接取需要的几个高位的数作为舍入结果。
互不干扰的序列不能直接取数舍入，必须依次将其有效位联合得到符合精度的一个数以至多个数。
ulp是按浮点格式定义的，表示了浮点数的精度。
而erp是按有效位数定义的，即使浮点数值0，其在上下文中的erp也可能大于非0浮点数。

带余加法：两个单数相加，只需组合非规格化的双数然後规格化以得结果。
带余减法：使用加法计算。
带余乘法：使用融合乘加，或者通过拆分单数以达到计算过程不损失精度。
带余除法：使用融合乘加计算余数，融合乘加可以通过带余乘法计算。

浮点数拆分算法：
inline dualdouble df_split_double(double a) {
  dualdouble ret;
  static const int64_t cvt_const = 0x3fa8000000000000LL;
  int64_t ix = *(int64_t *)&a;
  int64_t ie = ix & (-1LL << 52);        // 取阶码和符号
  int32_t it = (int32_t)ix << (32 - 27); // 27=(52+2)/2
  if (it < 0) {                          // 如果高位非0,需要进位取反
    ie ^= (1LL << 63);
    it = -it; // 即使it为最小负数也没问题
  }
  ix = cvt_const | it; // 进行转换,不会溢出
  ret.lo = *(double *)&ie * (*(double *)&ix - *(double *)&cvt_const); // 2^(-57)
  ret.hi = a - ret.lo; // ret.lo可能会下溢
  return ret;
}
为了将单数拆分为双数，且满足接下来的乘法不损失精度，要求拆分的高位和低位的有效位数不超过单数的一半。
double有53位尾数，因此拆分後的高位和低位应该有26位，然而两个26位加起来是52位。
考虑到两个双数中间的一位可以隐藏起来，因此还是可以做到无损拆分的。
先将之拆分为高26位和低27位，判断低27位的最高位是否为1(则取反使之为0)，从而使低位有效位数为26，然後通过减法计算高位(这样的高位可能有27位，但无损乘法是没问题的)。
inline double fmulsub_lim(double a, double b, double c) {
  dualdouble da, db;
  double ret;
  da = df_split_double(a);
  db = df_split_double(b);
  ret = (((da.hi * db.hi - c) + da.hi * db.lo) + da.lo * db.hi) + da.lo * db.lo;
  return ret;
}
inline dualdouble dmul(double a, double b) {
  dualdouble ret;
  ret.hi = a * b;
  ret.lo = fmulsub_lim(a, b, ret.hi);
  return ret;
}
这种无损乘法能够处理几乎所有规格化数和部分非规格化数，唯有下溢会导致dmul(a,b).lo与fma(a,b,-a*b)的误差。

双双数的规格化：
双数加减法，简单的组合一个非规格化的双双数，然後规格化，只取高位双数返回。
双双数的规格化算法可以推广到任何众数无损加法。
先从双数规格化考虑：
      A
      ↓
    ┏━┿━┓
B──→┨ + ┠──→D
    ┗━┿━┛
      ↓
      C
这样的部件称为快加器，用作双数{A,B}的规格化并输出双数{C,D}.

      A
      ↓
    ┏━┿━┓
B──→╂─+ ┠──→D
    ┗━┿━┛
      ↓
      C
这样的部件称为全加器，用作带余加法，A+B={C,D}.
全加器与快加器的区别只有，全加器不区分输入端，而快加器要保证输入端顺序按erp排序。特性如下：
输入:A,B. 全加器无限制,快加器要求:erp(A)>=erp(B).
输出:C,D. A+B==C+D 且 abs(D)<=0.5*ulp(C).
推论:erp(D)==min{erp(A),erp(B)}. 这是非常明显的,故不证。

先考虑以下的抗重叠数据流图：
      a0           a1           a2           a3     
      ↓            ↓            ↓            ↓      
    ┏━┿━┓   r0   ┏━┿━┓   r1   ┏━┿━┓          │      
b0←─╂─+ ┠←──────←╂─+ ┠←──────←╂─+ ┠←─────────┘      
    ┗━┯━┛        ┗━┯━┛        ┗━┯━┛                 
      ↓            ↓            ↓                   
      b1           b2           b3                  
能证明输出的{b0,b1,b2,b3}是互不干扰的。(根据浮点表示,有: erp(x)>=ulp(x))
0.5*ulp(b0)>=abs(b1), 0.5*erp(b1)=0.5*erp(r0)>=0.5*ulp(r0)>=abs(b2), 0.5*erp(b2)=0.5*erp(r1)>=0.5*ulp(r1)>=abs(b3). 故而得证。
但是该数据流图使用快加器，要求erp(a2)>=erp(a3),erp(a1)>=erp(r1)≈erp(a2+a3),erp(a0)>=erp(r0)≈erp(a1+a2+a3).

双双数的规格化可以使用上述抗重叠数据流图，首先应该分别对高位双数和低位双数规格化，
然後判断高位双数的低位和低位双数的高位的绝对值大小，使双双数再次满足按erp排序，
经过此处理後，在向零舍入(或舍入到奇数)的浮点环境下，满足抗重叠数据流图的输入要求。
证明：两个规格化双数的元素按绝对值排序组合的双双数可以满足抗重叠数据流图的输入要求。
设规格化双数{a0,a1},{b0,b1},erp(a0)>=erp(b0). 组合成双双数後，有：
{a0,a1,b0,b1}, erp(b0+b1)==erp(b0)<=erp(a1), ok
{a0,b0,a1,b1}, erp(a1+b1)<=erp(b0+b1)==erp(b0), erp(b0+a1+b1)<=erp(a0+a1+b1)≈erp(a0), ok
{a0,b0,b1,a1}, erp(b0+b1+a1)<=erp(a0+b1+a1)≈erp(a0), ok
注意:在{a0,b0,a1,b1}或{a0,b0,b1,a1}情况下,计算可能会:erp(a0+b1+a1)==2*erp(a0),这不会导致错误,因为此时快加器的输入要求其实略宽。
使快加器输出结果精确的输入要求：
A+B=C+D:
C=A+B;
D=(A-C)+B; // 这一步必须精确
当 A=2^k-eps,B=2^k 时，也能得到精确结果，这是因为在向零舍入(或舍入到奇数)的浮点环境下有 C=2^(k+1)-eps,
如果采取向无穷舍入(或舍入到偶数)的浮点环境则 C=2^(k+1) 导致计算D时不精确。

在抗重叠数据流图之後，只需要从输出的高位到低位依次组成满足精度的多个单数即可，这样既可得到舍入结果也可得到余数。
如果只需要双数加法的结果，则可以简单处理：
      b0           b1           b2           b3     
      ↓            ↓            ↓            ↓      
    ┏━┿━┓          │          ┏━┿━┓          │      
hi←─╂─+ ┠←───────────────────←╂─+ ┠←─────────┘      
    ┗━┯━┛          │          ┗━┯━┛                 
      ↓            ↓            ↓                   
lo←───┷────────────┷────────────┘                   
如果b1值非0则可以直接处理: hi=b0; lo=b1+b2+b3;
判断b1值是否为0对单数据流来说是有意义的，多数据流应该避免这样的分支。

无论多少个数进行规格化，都可以转化为多次两个双数的加法，
个数不是2的幂次的情况下应补足个数再进行，对于这些处理流程，可以根据需要进行简化。

现在证明规格化的众数相加，在向零舍入(或舍入到奇数)的浮点环境下，只需要把数据按绝对值排序就可以进行抗重叠数据流图：
两个规格化众数{a0,a1,a2,...,an},{b0,b1,b2,...,bm}相加，先将数据按绝对值排序得{a0|b0,(a1|b0)|(b1|a0),...},
只需证：erp(max{a0,b0})>=erp(all-max{a0,b0}).
令erp(a0)>=erp(b0),则需证：erp(a0)>=erp(a1+a2+...+an + b0+b1+...+bm).
很明显，当erp(a0)>erp(b0)时，上式成立。
当erp(a0)==erp(b0)时，erp(b0+a1+b1)<=erp(b0+abs(a1)+abs(b1))<=erp(b0+0.5*erp(a0)+0.5*erp(b0))==erp(b0+erp(a0))≈erp(a0)
唯有产生进位误差会导致erp(a0)<erp(b0+a1+b1),但是这种情况下仍然可以通过抗重叠数据流图(此时输出可能不是互不干扰的,而是互不重叠的).
很明显：erp(b0+a1+b1)≈erp(b0+a1+b1+ a2+....+an+ b2+...+bm),此误差也在容许范围内。
因此，在向零舍入(或舍入到奇数)的浮点环境下，两个规格化众数的数据按绝对值排序後，可以直接通过抗重叠数据流图。
只是，如果不严格满足输入要求，那么输出结果可能不是互不干扰的，但至少是互不重叠的。
因此，对输出结果从高位到低位依次组合(此时恢复舍入模式)成多个单数，能正确得到加减法的结果。

以上讨论说明了，舍入到奇数很可能优于舍入到偶数，但是默认浮点环境是舍入到最接近且优先偶数，不提供舍入到奇数的模式。
推荐硬件实现"舍入到最接近且优先奇数"的模式并作为默认浮点环境，因为此模式不仅不会造成统计偏差，也不会产生范围外的数，且更适用于双数运算。

双数加法：
                               a0             a1   
b0───────────────────┐         │              │    
                     ↓         │              │    
                   ┏━┿━┓       │              │    
           ┌──────←╂─+─┨←──────┘              │    
           │       ┗━┯━┛                      │    
           │         ↓                        │    
b1─────────│─────────│─────────┐              │    
           ↓e        ↓d        ↓              │    
         ┏━┿━┓     ┏━┿━┓  c  ┏━┿━┓            │    
 ┌──────←╂─+ ┠←───←╂─+─┨←───←╂─+─┨←───────────┘    
 │       ┗━┯━┛     ┗━┯━┛     ┗━┯━┛                 
┄↓┄┄┄┄┄┄┄┄┄↓┄┄┄┄┄┄┄┄┄↓┄┄┄┄┄┄┄┄┄↓┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄ 
 └─────┐   └──┐      │         │                   
     r0↓    r1│    r2↓       r3│                   
     ┏━┿━┓    │    ┏━┿━┓       │                   
hi──←╂─+ ┠←───│───←╂─+ ┠←──────┘                   
     ┗━┯━┛    │    ┗━┯━┛                           
       ↓      ↓      ↓                             
lo←────┷──────┷──────┘                             
很明显，{r0,r1,r2}是互不干扰的(可以视为{c,d,e}通过两个快加器组成的抗重叠数据流图)，
erp(r2)==min{erp(c),erp(d)}, abs(r3)<=0.5*erp(c).
abs(r3)<=min{abs(a1),abs(b1)}<=0.5*min{ulp(a0),ulp(b0)}<=0.5*min{erp(a0),erp(b0)}==0.5*erp(d).
=> abs(r3)<=0.5*erp(r2). 故而r2与r3不干扰。
因而{r0,r1,r2,r3}是互不干扰的。上述双数加法的数据流图是正确的(此方式不需要更改舍入模式)。

双数减法：只需减数取反，然後相加。


双数乘法：
首先是乘法器，如下：
      A
      ↓
    ┏━┷━┓
B──→┨ × ┠──→D
    ┗━┿━┛
      ↓
      C
C=A*B, D=fms(A,B,C).
最後是双数乘法的数据流图：
          a0              a1                  
          ├────────┐      ├────────┐          
          ↓        │      ↓        │          
        ┏━┷━┓      │    ┏━┷━┓      │          
b0────┬→┨ × ┠→┐    │  ┌→┨ × ┠→─────│────┐     
      │ ┗━┿━┛ │    │  │ ┗━┿━┛      │    │     
      │   ↓   │    │  │   ↓        │    │     
      └───│───│────│──┘ ┌─│────────│───→┥     
          │   │    ↓    │ │        ↓    │     
          │   │  ┏━┷━┓  │ │      ┏━┷━┓  │     
b1────┬───│───│─→┨ × ┠→─┘ │   ┌─→┨ × ┃  │     
      │   │   │  ┗━┿━┛    │   │  ┗━┿━┛  │     
      │   │   │    ↓      │   │    ↓    │     
      └───│───│────│──────│───┘    └───→┥     
          │   │    │      ↓             │     
          │   │    │    ┏━┿━┓           │     
          │   │    └───→╂─+ ┠→─────────→┥     
          │   │         ┗━┿━┛           │     
          │   │           ↓             │     
          │   │    d    ┏━┿━┓           │     
          │   └────────→╂─+ ┠→─────────→┥     
         r│             ┗━┿━┛           │     
          ↓               ↓             │     
        ┏━┿━┓      c    ┏━┿━┓           │     
      ┌←╂─+ ┠←─────────←╂─+ ┠←──────────┘     
      │ ┗━┯━┛           ┗━┯━┛                 
┄┄┄┄r0↓┄┄┄↓r1┄┄┄┄┄┄┄┄┄┄┄┄┄↓r2┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄ 
      │   └───────────────┿┄┄┄┄┄┄┄┄┄┄┄┄┄┄drop 
      ↓                   ↓                   
      hi                  lo                  
很明显，最後进行{c,r2}与r的加法以得到结果，之前计算的误差不会大于2^(-107)，只要r0与r2完全不干扰就能保证正确。
{r0,r1,r2}是互不干扰的，{r0,r1}是完全不干扰的，如果r1!=0则r0与r2也是完全不干扰的。
如果 r1==0,r2!=0 ，则有：c!=0, r≈a0*b0, 有不等式：ulp(a)*b<=2*ulp(a*b).
c≈a1*b0+a0*b1+d+a1*b1<=0.5*ulp(a0)*b0+a0*0.5*ulp(b0)+0.5*ulp(a0*b0)+0.5*ulp(a0)*0.5*ulp(b0)<2.5000...1*ulp(a0*b0).
故而erp(c)远小于erp(r), ulp(r0)≈ulp(r+c)≈ulp(r) 远大于 ulp(c)>=0.5*abs(r2), => ulp(r0)>0.5*abs(r2).
也即r0与r2完全不干扰，即上述双数乘法的数据流图是正确的。

双数乘法只需要乘积的前两个单数作为结果，余数是没有多大意义的(余数最多是6个单数)，
上述数据流图可以非常精确的计算双数乘法(误差略大于0.5ulps)，如果允许更大误差可以更优化。


双数除法：
利用长除法，求出三个单数作为商，然後从低位到高位重整。
首先是必要的部件图：
除法器：
      A
      ↓
    ┏━┷━┓
B──→╊>÷ ┠──→D
    ┗━┿━┛
      ↓
      C
C=A/B, D=-fms(C,B,A).
倒数器：
A────>────→B
B=1/A.
除法迭代器：
        A
        ↓
B────→┳━┻━┓
RB───→╂ ÷ ┠──→D
      ┗━┿━┛
        ↓
        C
C=A*RB, D=-fms(C,B,A).
取反器：
A────○────→B
B=-A.
最後是双数除法的数据流图：
              a0              a1           
              ↓               ↓            
            ┏━┷━┓     r     ┏━┷━┓          
b0──────┬──→╊>÷ ┠→─────────→╂─+ ┠→───┐     
        │   ┗━┿━┛           ┗━┿━┛    │     
        │     ↓q              ↓      │     
    ┌───│─────┤      ┌────────│─────→┥     
    │   │     ↓      │        ↓      │     
    │   │   ┏━┷━┓    │      ┏━┿━┓    │     
b1──│─┬─│──→┨ × ┠→○──┘  ┌──→╂─+ ┠→──→┥     
    │ │ │   ┗━┿━┛       │   ┗━┿━┛    │     
    │ │ │     ↓         │     ↓      │     
    │ │ │     └───○─────┘     │      │     
    │ │ │        ┌────────────┘      │     
    │ │ │   ┌────│──────┐  ┌─────┐   │     
    │ │ │   │    ↓      │  │     ↓   │     
    │ │ ├───│─→┳━┻━┓    │  │   ┏━┻━┓ │     
    │ │ └─>─┴─→╂ ÷ ┠→─┐ └──│──→╂ ÷ ┃ │     
    │ │        ┗━┿━┛  │    │   ┗━┿━┛ │     
    │ │          ↓    │    │     ↓   │     
    │ │     ┌────┤    │    │     │   │     
    │ │     │    ↓    └───→┥     │   │     
    │ │     │  ┏━┷━┓       │     │   │     
    │ └─────│─→┨ × ┃       │     │   │     
    │       │  ┗━┿━┛       │     │   │     
    │       │    ↓         │     │   │     
    │       │    └──○─────→┷─────│───┘     
┄┄┄┄↓┄┄┄┄┄┄┄↓┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄↓┄┄┄┄┄┄┄┄ 
  ┏━┿━┓   ┏━┿━┓                  │         
┌←╂─+ ┠←─←╂─+ ┠←─────────────────┘         
│ ┗━┯━┛   ┗━┯━┛                            
│   ↓       ↓                              
│   └───────┷───┐                          
↓               ↓                          
hi              lo                         
双数除法的基本原理是除法迭代(长除法)，第一次上商采取除法器而不是除法迭代器，
这是因为第一次求余数必须精确，如果用除法迭代器则余数不能用一个单数精确表示(这对余数计算更复杂)，
余数经过修正後可以进行下一次迭代，再次计算余数就不需要精确计算(三个商的精度足够)。
最後，三个商需要重整为一个双数，由于三个商之间不是互不重叠的，需要经过抗重叠数据流图。
现在证明除法器的余数可以用一个单数精确表示：
设浮点有p位精度，有：a=0.1A*2^p, b=0.1B*2^p,
为了计算p位的商需要把a左移p或p+1位，根据整数除法的性质，余数必定小于除数(即使进行舍入)，
因此浮点除法的余数的位数必定小于除数，故而可以用一个单数表示。
此外，还需证明图中除法器余数r的误差阶数不小于a1，如下：
erp(a1)==ulp(a1)<=ulp(0.5*ulp(a0)), 设：a0=0.1A*2^m, b0=0.1B*2^n, 浮点精度p位，则：
erp(a1)<=ulp(0.5*ulp(a0))==2^(m-2*p).
为了计算p位的商，将a0和b0乘以2的幂次得到：a=0.1A*2^(2*p-1)或0.1A*2^(2*p), b=0.1B*2^p, 两个整数。
当0.1A>=0.1B时，a=0.1A*2^(2*p-1), erp(r)>=erp(a)/2^(2*p-1-m)==2^(m-2p+1)>erp(a1).
当0.1A<0.1B时，a=0.1A*2^(2*p), erp(r)>=erp(a)/2^(2*p-m)==2^(m-2p)>=erp(a1).
故erp(r)>=erp(a1)成立(亦即浮点运算中 erp(a%b)>=ulp(0.5*ulp(a)) 恒成立)。
综上所述，上述双数除法的数据流图是正确的。

双数除法只需要两个单数作为结果，余数是没有多大意义的(余数最多是6个单数)，
上述数据流图可以非常精确的计算双数除法(误差略大于0.5ulps)，如果允许更大误差可以更优化。
如果多次进行除以同一个数的除法，应该转换为与倒数相乘来优化，取倒数比除法略快，而除法比乘法略慢。


算法误差分析：
double双数的表示误差是err=±0.5*ulp(0.5*ulp(hi)-eps(lo))，精度误差是eps=abs(err)/(2^ilogb(hi))=2^(-107).
故而double双数至少有107位精度。
1、快速双数加单数
             a0           a1                  
             ↓            ↓                   
           ┏━┿━┓ r1       │                   
b─────────→╂─+ ┠→─────────┿┄┄┄┄┄┄┄┄┄┄┄┄┄┄→err 
           ┗━┿━┛          ↓                   
             ↓          ┏━┷━┓                 
             └─────────→╂─+ ┠→─────────┐      
                        ┗━┿━┛          │      
                          ↓            ↓      
                          hi          lo      
abs(err)<=0.5*ulp(a1+r1)<=0.5*ulp(a1±0.5*ulp(a0+b))≈0.5*ulp(ulp(a0+b)-eps(a1))≈ulp(ret)*2^(-54).
请注意：当r1值0时不会有误差。根据相关资料的结果，abs(err)<2^(-105)*abs(ret).
很明显，eps=abs(err)/(2^ilogb(ret))<=2^(-52)*2^(-54)=2^(-106). 即此时(通常情况)，计算结果有106位精度。
由于计算误差，可能出现abs(err)==0.5*ulp(ulp(ret)),(eps(a1)被忽略)的情况，此时计算结果只有105位精度。

2、快速双数加法
             a0           a1                  
             ↓            ↓                   
           ┏━┿━┓ r1     ┏━┿━┓ r2              
b0────────→╂─+ ┠→┐    ┌→╂─+ ┠→┐               
           ┗━┿━┛ │    │ ┗━┿━┛ │               
             ↓   │    │   ↓   │               
err1┄┄┄┄┄┄┄┄┄│┄┄┄┿────│───┘   │               
b1───────────│───│────┘ ┌─────┿┄┄┄┄┄┄┄┄┄┄err2 
             │   ↓      │     ↓               
             │ ┏━┷━┓ r3 │   ┏━┷━┓             
             └→╂─+ ┠→───┘ ┌→╂─+ ┠→─────────┐  
               ┗━┿━┛      │ ┗━┿━┛          │  
                 ↓        │   ↓            │  
                 └────────┘   hi          lo  
此误差的证明比较难，结论是abs(err)<2.25*2^(-106)*abs(ret). 即通常有106位精度，最坏情况下只有104位精度。

3、简陋双数加法
             a0           a1           
             ↓            ↓            
           ┏━┿━┓ r1       │            
b0────────→╂─+ ┠→┐        │            
           ┗━┿━┛ │        │            
             ↓   │     r2 │            
err2┄┄┄┄┄┄┄┄┄│┄┄┄┿───────←┿┄┄┄┄┄┄┄err1 
b1────────→──│───│────────┘            
             │   ↓                     
             │ ┏━┷━┓                   
             └→╂─+ ┠→─────────┐        
               ┗━┿━┛          │        
                 ↓            ↓        
                 hi          lo        
此计算结果的误差是源误差，不是相对误差，根据相关资料，abs(err)<2^(-104)*(abs(a)+abs(b))==2^(-104)*abs(ret),(a,b同号).
